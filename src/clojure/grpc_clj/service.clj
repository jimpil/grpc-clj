(ns grpc-clj.service
  (:require [camel-snake-kebab.core :as csk]
            [grpc-clj.context :as context]
            [pronto.core :as pronto]
            [grpc-clj.state :as state]
            [grpc-clj.util :as util]
            [grpc-clj.middleware :as middleware]
            [grpc-clj.error :as error]
            [clojure.pprint])
  (:import [io.grpc Context Status]
           [io.grpc.stub StreamObserver]))

(defmacro impl
  "Implement gRPC service `SERVICE` in current namespace, importing all necessary Java classes and preparing
  environment. By providing necessary details in form `JAVA-PACKAGE` and `JAVA-OUTER-CLASS-NAME` (which are defined in
  `.proto` file), it will hopefully guess naming of Java classes automatically."
  [service-name & {:keys [java-package java-outer-classname metadata]}]
  {:pre [(or (symbol? service-name)
             (string? service-name))
         (string? java-package)
         (string? java-outer-classname)]}
  (list
    'do
     `(gen-class :name ~(util/class-symbol-for-service (ns-name *ns*) service-name)
                :prefix "rpc-"
                  ;; extends class autogenerated by `lein protoc && lein javac` from proto file
                :extends ~(symbol
                           (str (cond->> (str service-name "Grpc")
                                  ;(some? java-outer-classname)
                                  ;(str java-outer-classname \$)
                                  (some? java-package)
                                  (str java-package \.))
                                \$
                                service-name
                                "ImplBase")))
    ;(clojure.core/import* ~(str (util/class-symbol-for-service (ns-name *ns*) service-name)))
     ;(println impl-class# "=>" (class impl-class#))
     `(swap! state/services assoc
             ~(str (util/class-symbol-for-service (ns-name *ns*) service-name))
             {})

    `(def ~'service-context
       (let [m# (into {}
                      (map (fn [k#]
                             (let [nk# (name k#)]
                               [nk# (Context/key nk#)])))
                      ~metadata)]
         (swap! state/services assoc-in
                [~(str (util/class-symbol-for-service (ns-name *ns*) service-name))
                 :context]
                m#)
         m#))
     ))

(defn reply-on!
  "Call gRPC `onNext` callback, replying on StreamObserver `RES` with message of type `TYPE` initielized with kebab-cased
  key-value map `DATA`.

  Example call:
    (reply! \"MessageType\" res
      {:name                  \"Name\"
       :description           \"Description\"})))
  "
  [^StreamObserver stream response-obj]
  (.onNext stream response-obj)
  (.onCompleted stream))


(defmacro defgrpc
  "Implement new RPC function `RPC-NAME` returning type `TYPE` within service being implemented in current namespace. 
   Use `ON-NEXT` function in `BODY` to reply."
  [rpc-function-name [req-type resp-type] middleware handler]
  (list
    'do
    ;; request-mapper
    `(pronto/defmapper
       ~(-> req-type (str "-mapper") csk/->kebab-case-symbol)
       [~req-type]
       :key-name-fn csk/->kebab-case)
    ;;response mapper
    `(pronto/defmapper
       ~(-> resp-type (str "-mapper") csk/->kebab-case-symbol)
       [~resp-type]
       :key-name-fn csk/->kebab-case)
    ;; overridden method from ImplBase
    (let [req-mapper  (-> (util/class-simple-name req-type)
                          (str "-mapper")
                          csk/->kebab-case-symbol)
          resp-mapper (-> (util/class-simple-name resp-type)
                          (str "-mapper")
                          csk/->kebab-case-symbol)]
      `(let [handler-fn# (util/resolve++ ~handler)
             handler# (or (some->> (not-empty ~middleware)
                                   (map #(if (symbol? %)
                                           (util/resolve++ %)
                                           (eval %)))
                                   (middleware/wrap-handler handler-fn#))
                          handler-fn#)]
         (defn ~(symbol (str "rpc-" (csk/->camelCaseString rpc-function-name)))
           [~'_ ~'req ~'stream]
          ; (println ~'service-context)
           ;(println ~handler*)
           (try
             (let [context#  (update-vals ~'service-context context/current-value)
                   response# (-> ~req-mapper
                                 (pronto/proto->proto-map ~'req)
                                 (with-meta context#)
                                 (handler#))]
               (->> response#
                    (pronto/clj-map->proto-map ~resp-mapper ~resp-type)
                    (pronto/proto-map->proto)
                    (reply-on! ~'stream)))
             (catch Throwable t#
               ;(println "OOPS!" t#)
               (.onError
                 ~(with-meta 'stream {:tag 'io.grpc.stub.StreamObserver})
                 (if-some [^Status status# (some-> (ex-data t#)
                                                   :grpc/status
                                                   error/codes)]
                   (-> status#
                       (.withDescription (ex-message t#))
                       (.asRuntimeException))
                   t#)))))))))

(comment

  (macroexpand-1
   '(defgrpc
      SayHello    ;; the fn-name/method we're overriding 
      [HelloRequest HelloReply]
      []           ;; middleware stack 
      `greet!))

  (macroexpand-1
   '(impl
     "Greeter"
     :java-package "com.foo.services"
     :java-outer-classname "greeting")))